import { createElement } from '@lwc/engine-dom';
import ContractChangeSubscriber from 'c/contractChangeSubscriber';
import { subscribe, unsubscribe, onError } from 'lightning/empApi';
import getContracts from '@salesforce/apex/ContractController.getContracts';

// Mock the Apex method
jest.mock('@salesforce/apex/ContractController.getContracts', () => ({
    default: jest.fn()
}));

// Mock the empApi methods
jest.mock('lightning/empApi', () => ({
    subscribe: jest.fn(),
    unsubscribe: jest.fn(),
    onError: jest.fn()
}));

describe('c-contract-change-subscriber', () => {
    afterEach(() => {
        // The jsdom instance is shared across test cases in a single file so reset the DOM
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }
    });

    it('TODO: test case generated by CLI command, please fill in test logic', () => {
        // Arrange
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });

        // Act
        document.body.appendChild(element);

        // Assert
        // const div = element.shadowRoot.querySelector('div');
        expect(1).toBe(1);
    });

    it('should render the component with a title', () => {
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });
        document.body.appendChild(element);

        const titleElement = element.shadowRoot.querySelector('lightning-card h2');
        expect(titleElement.textContent).toBe('Contract Updates (Real-time)');
    });

    it('should display contract data when available', () => {
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });

        // Mock the getContracts method to return a successful response
        getContracts.mockResolvedValue([
            { Id: '1', Name: 'Contract 1', Status__c: 'Active' },
            { Id: '2', Name: 'Contract 2', Status__c: 'Inactive' }
        ]);

        document.body.appendChild(element);

        return Promise.resolve().then(() => {
            const contractElements = element.shadowRoot.querySelectorAll('p');
            expect(contractElements).toHaveLength(2);
            expect(contractElements[0].textContent).toContain('Contract 1');
            expect(contractElements[1].textContent).toContain('Contract 2');
        });
    });

    it('should display a message when no contract data is available', () => {
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });

        // Mock the getContracts method to return an empty response
        getContracts.mockResolvedValue([]);

        document.body.appendChild(element);

        return Promise.resolve().then(() => {
            const messageElement = element.shadowRoot.querySelector('p');
            expect(messageElement.textContent).toBe('No contract data available.');
        });
    });

    it('should handle contract updates via the event channel', () => {
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });

        // Mock the getContracts method to return a successful response
        getContracts.mockResolvedValue([
            { Id: '1', Name: 'Contract 1', Status__c: 'Active' }
        ]);

        document.body.appendChild(element);

        // Simulate a contract update event
        const messageCallback = subscribe.mock.calls[0][2];
        messageCallback({
            data: {
                payload: {
                    ChangeEventHeader: {
                        changes: ['Status__c'],
                        recordIds: ['1']
                    }
                }
            }
        });

        return Promise.resolve().then(() => {
            const contractElements = element.shadowRoot.querySelectorAll('p');
            expect(contractElements).toHaveLength(1);
            expect(contractElements[0].textContent).toContain('Contract 1');
        });
    });

    it('should handle errors when loading contract data', () => {
        const element = createElement('c-contract-change-subscriber', {
            is: ContractChangeSubscriber
        });

        // Mock the getContracts method to return an error
        getContracts.mockRejectedValue(new Error('Error loading contracts'));

        document.body.appendChild(element);

        return Promise.resolve().then(() => {
            const errorElement = element.shadowRoot.querySelector('.error');
            expect(errorElement.textContent).toBe('Error loading contracts: Error: Error loading contracts');
        });
    });
});